# mutex实现

golang中的锁是通过CAS原子操作实现的，Mutex结构如下：
```go
type Mutex struct {
    state int32           //state表示锁当前状态，每个位都有意义，零值表示未上锁      
    sema  uint32        //sema用做信号量，通过PV操作从等待队列中阻塞/唤醒goroutine，等待锁的goroutine会挂到等待队列中，并且陷入睡眠不被调度，unlock锁时才唤醒。具体在sync/mutex.go Lock函数实现中。
}
```

## Lock方法申请对mutex加锁的时候分为两种情况：

有冲突：通过SAS把当前状态设置为加锁状态。
无冲突：通过调用semacquire函数进入休眠状态，等待其他协程释放锁的时候唤醒。

## UnLock 解锁分两步：

解锁，通过CAS操作把当前状态设置为解锁状态。
唤醒休眠协程，CAS操作把当前状态的waiter数减1,然后唤醒休眠goroutine。

## 自旋锁(spinlock)
自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，
然后不断地判断是否能够被成功获取，知直到获取到锁才会退出循环。
获取锁的线程一直处于活跃状态 Golang中的自旋锁用来实现其他类型的锁,与互斥锁类似，不同点在于，
它不是通过休眠来使进程阻塞，而是在获得锁之前一直处于活跃状态(自旋)。

Lock 方法申请对 mutex 加锁的时候分三种情况：
无冲突 通过 CAS 操作把当前状态设置为加锁状态。
有冲突 开始自旋，并等待锁释放，如果其他 goroutine 在这段时间内释放了该锁，直接获得该锁；如果没有释放，进入3。
有冲突 通过调用 semacquire 函数来让当前 goroutine 进入等待状态，等待其他协程释放锁的时候唤醒。


### 原子操作的理解：  
1  一个全局int变量，多核中一个goroutine读，一个写，没有更多操作，需不需要做原子操作。  
   应该是不需要加的，intel P6处理器在硬件层面上是支持32位变量的load和store的原子性的。另外编译器对于变量的读或写也不会编译成多条指令。  
 
2   一个全局int变量i, 对于多核，两个协程都同时执行i++，需要原子操作吗？  
    需要的，对于i++，是典型的读改写操作，对于这样的操作，需要CAS原子操作保证原子性。  
 
3  对于一个map，写加原子操作，读要不要加  
    如果只是读或者写，并且值类型是整形的，应该是不需要atomic原子操作的，这里的意思是对于整形，不会出现写一半，或者读一半的情况，但是不可避免的，会出现这种情况，goroutine1对map写入1，goroutine2读到1，在处理的过程中，goroutine1又重新赋值。  